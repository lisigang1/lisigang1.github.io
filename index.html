<!DOCTYPE html>
<html lang="en">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="LSG的博客">
  <meta name="author" content="Faker">
  <meta name="keywords" content="javaScript">
  <title>faker</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
  
  <link rel="stylesheet" href="/css/main.css">

  
</head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>faker</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fa fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      <div class="container nopadding-md">
        <div class="py-5 z-depth-3" id="board">
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                


  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/19/存储的作用/">
        <p class="h4 index-header">存储的作用</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">存储的作用什么时候会用到本地存储？本地存储的作用？
记住用户名和密码（或者自动登录）
未登录状态下，加入购物车的信息一般也先存储在本地，当登录后，把信息存储到服务器上（目的是多平台数据共享）
对于非实时刷新数据，我们可以在从服务器把数据获取到后，临时存储在本地（设置有效时间），在有效时间内页面刷新，不再重新从服务器获取数据，而是读取本地数据；超过有效时间重新从服务器拉取…  “前端性能优化的一点”
还能实现同一个网站不同页面之间的信息共享和通信

本地存储到底存储在哪了？
本地存储是受浏览器限制的，例如：在谷歌中存储的数据，在IE中获取不到 

受源(域)的限制，例如：都是用谷歌浏览器，我在京东下存储的数据，在百度中是获取不到的

本地存储的信息在控制台中可以查看到（而且是明文存储），所以敏感的数据尽可能不要存储在本地，非要存储也要做安全处理（例如：加密）
12345678910111213141516171819- setItem([key],[value]) 存储信息 - getItem([key]) 获取信息- removeItem([key]) 移除某一项信息- clear()</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-19&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/19/一个倒计时案例/">
        <p class="h4 index-header">一个倒计时案例</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">一个倒计时案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//new Date()获取客户端本地当前时间（不能拿它做重要依据，因为用户可以随意修改）		/* 		 * 倒计时抢购需要从服务器获取当前时间  AJAX		 *    问题：时间差（从服务器把时间给客户端，到客户端获取到这个信息，中间经历的时间就是时间差，而时间差是不可避免的，我们应尽可能减少这个误差）		 *    - 从响应头获取时间（AJAX异步）		 *    - 基于HEAD请求（只获取响应头信息）		 */		let target = new Date('2019/09/14 13:27:00'),			now = null,			timer = null;		//=&gt;从服务器获取时间：获取到时间后再做其他的事情		function func(callback) &#123;			let xhr = new XMLHttpRequest;			xhr.open('HE</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-19&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/19/权限校验从用户成功登陆开始/">
        <p class="h4 index-header">权限校验</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">权限校验从用户成功登陆开始​    1. 服务器校验


客户端做某个操作的时候=&gt;服务器根据登陆者的角色，进行权限校验，返回给客户端是否可以操作 =&gt; 服务器返回给客户端能否操作的标识
或者不确定哪些内容用户可以看的，都向服务器发请求，由服务器告知我们，那些需要展示

弊端：服务器要处理的请求和对应的压力较大
优势：安全


客户端校验


当用户登录成功后，服务器会把该用户拥有的权限，返回给客户端(或者客户端可以基于某个API接口从服务器获取权限)

客户端根据获取的权限校验标识，控制那些显示，那些隐藏，或者进行某些操作的时候进行对应的提示

问题：在某个页面中获取的权限校验码，需要在其它页面使用 =&gt; 我们一般基于本地存储完成的(VUE/REACT中式存储到redux/vuex中的)，如果服务器支持获取权限的接口，也可以每次都从服务器重新获取
优势：不需要频繁向服务器发送请求，获取校验码后，一切判断客户端来处理，这样减少业务逻辑的复杂度，也减轻了服务器的压力；而且每次验证是否存在权限的速度也快…
弊端：因为客户端本地校验(有可能还要把信息存储在客户端本地)，容易</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-19&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/19/AJAX核心处理/">
        <p class="h4 index-header">AJAX的学习</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">AJAX核心处理
 支持的参数配置项

url
method:’GET’
data:null
dataType:’json’
async:true
cache:true
success:null
error:null
headers:null
timeout:null


1234567891011121314/* ==AJAX处理的核心== */let regGET = /^(GET|DELETE|HEAD|OPTIONS)$/i;let defaults = &#123;	url: '', //=&gt;请求的API接口地址	method: 'GET', //=&gt;请求方式 GET/POST/DELETE/PUT/HEAD/OPTIONS	data: null, //=&gt;传递给服务器的信息：支持格式STRING和OBJECT，如果是OBJECT，我们需要把其处理为x-www-form-urlencoded格式；GET请求是把信息作为问号参数传递给服务器，POST请求是放到请求主体中传递给服务器；	dataType: 'JSON', //=&gt;把服务器返回结果处理成为对</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-19&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/19/服务器和客户端渲染机制/">
        <p class="h4 index-header">服务器和客户端</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">服务器和客户端渲染机制服务器接收到请求后

找到对应的页面，获取到页面的代码

再根据需求从数据库中获取到需要动态展示的数据

把页面和数据混合在一起进行渲染，声称有结构有内容的完整页面
= &gt; 服务器渲染

把渲染玩的页面返回给客户端




服务器渲染的特点

我们看到的内容都是在服务器端渲染完的(JSP、PHP、ASP、ASP.NET、NODE…)，客户端只是把所有渲染好的内容呈现在页面中而已；然而我们第一次渲染完，页面中的某部分数据需要更新了，我们需要让服务器整体重新的渲染一次，把最新的页面(包含最新的数据)返回给客户端，客户端只能整体刷新页面展示最新的内容 = &gt;”全局刷新”性能和体验等都非常差，而且服务器压力也很大…
如果服务器性能比较高，页面展现出来的速度会快一些，因为只要从服务器拿到内容，一切信息都已经准备好了
由于内容在服务器端已经渲染好了，所以页面渲染完成后，在页面的源代码中哪个都可以看到内容，有利于SEO搜索引擎优化


客户端渲染数据的内容

可以实现页面中内容的局部刷新，而且渲染的操作交给客户端来做=&gt;体验好、减轻了服务器压力
而且开始可以只</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-19&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/19/URL地址经历了什么/">
        <p class="h4 index-header">URL都经历了什么</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">URL地址经历了什么当我们输入URL按下Enter键经历了什么
URL地址解析

DNS域名解析

和服务器建立TCP链接

把客户端信息传递给服务器(发送HTTP请求)

服务器得到并处理(HTTP响应内容)

客户端渲染服务器返回的内容

和服务断开TCP链接
### 
服务器端和客户端
客户端：可以向服务器发请求，并接收返回的内容进行处理服务器端：能够接收客户端请求，并且把相关资源信息返回给客户端的

URI/URL/URN
URL（Uniform Resource Locator）：统一资源定位符，根据这个地址能找到对应的资源
URN（Uniform Resource Name）：统一资源名称，一般指国际上通用的（标准的）一些名字（例如：国际统一发版的编号）
URI（Uniform Resource Identifier）：统一资源标识符，URL和URN是URI的子集

一个完整的URL所包含的内容
http://www.zhufengpeixun.cn:80/stu/index.html?from=wx&amp;lx=1#zhenyu


协议（http://）：传输协议就是</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-19&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/18/点击登录按钮经历了什么/">
        <p class="h4 index-header">点击登录按钮中间经历了什么</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">点击登录按钮经历了什么
第一步：   获取用户输入的用户名和密码（表单验证）
 第二步：   基于ajax向服务器发请求，把用户名和密码传递给服务器通过post
 第三步：服务器接收到信息后，把密码二次加密，在收到数据库中查找是否存在用户名和密码相匹配的人员，   如果找不到，只需要告诉客户端，用户名和密码不匹配   如果找到了，“在服务端记录当前用户的登录态”   \1. 在服务器设置一个session （connect_sid)存储当前用户已经登录了登录态   \2. 获取当前用户能操作的权限信息，连同登录成功的信息一并返回给客户端
第四步： 把最后操作的结果告诉客户端
第五步：客户端获取信息后，进行相关操作

信息加密(密码都是不可逆转的)
可逆转加密（按照规则加密，再按照规则解密）

不可逆转加密（一旦进行加密，不能再解密）MD5 =&gt;密码一定是不可逆转的。增加用户的时候，把用户密码进行MD5加密，把加密的结果存储到数据库中，登录的时候把输入的密码还是MD5加密，拿加密的结果和之前存储的结果进行匹配，如果一样，则说明两次输入的原始密码是一致。&gt; 为了防止用户输入的密</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-18&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/18/项目一/">
        <p class="h4 index-header">做一个小项目</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">项目一
项目结构目录

​    |- admin 存储我们所有的后台程序
​    |- client 客户端（前端）所有的程序

admin

&gt; 首先跑环境：$ npm i 
&gt; 纠正一些基础的配置：config.js
&gt;   - PORT 后台程序运行的端口
&gt;   - CROS.ALLOW_ORIGIN 客户端程序运行的服务地址
&gt; 启动服务：$ node server.js
&gt; 启动后的运行窗口不能关闭，关闭则后台服务器结束

客户端采用的技术栈：

- HTML5/CSS3（会用到字体图标）
- JQUERY
- AXIOS
- 辅助插件：JQUERY.COOKIE / MD5 / 自己写的一些方法
- 基于IFRAME构建最初版本的SPA单页面应用开发
服务端采用的技术栈：
- NODE
- EXPRESS / EXPRESS-ROUTER
- 本应基于数据库存储，为了方便简单，当前项目临时采用JSON文件存储数据
- SESSION
-—————-
本地存储 VS 服务器存储
本地存储：把信息存储在客户端本地

&gt; 谷歌控制台</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-18&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/17/自己封装的Promise版(ajax)/">
        <p class="h4 index-header">自己封装的promise版ajax</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">自己封装的Promise版(ajax)支持的功能
1.支持全局默认配置项 _ajax.defaults.xxx=xxx
2.发送请求_ajax.get/post…
3.每一次请求都会返回PROMISE实例，基于PROMISE设计模式进行管理
4.支持_ajax.all
/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-17&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/09/17/promise/">
        <p class="h4 index-header">Promise</p>
        <div class="index-excerpt">
          
            <div class="index-text mb-1">More info: Deployment
一、什么是promiseES6 语法规范中新加的内置类，用来处理 js 中异步编程的，而我们所谓的 Promise 设计模式，就是基于 promise 对异步操作进行管理promose 是一个内置类，所以创建一个 promise：new Promise([executor]): 第一个执行函数必须传递，这里的 executor 是一个回调函数下面简称 exenew promise 的时候就会把 exe 执行，创建 promise 的一个实例（exe 是 promise 类的一个回调函数，promise 内部会把它执行）promise 不仅把 exe 执行，而且还给 exe 传递两个参数（两个参数也是函数类型）resolve 函数：它执行代表 promise 处理的异步事情是成功的，把 promise 的状态改为 fulfilledreject 函数：它执行代表 promise 处理的异步事情是失败的，把 promise 的状态改为 rejectedexe 函数中放的就是当前要处理的异步操作事情let promiseExamp = new Pr</div>
          
        </div>
      </a>

        <div>
          
            <i class="iconfont icon-riqi2"></i>&nbsp;2019-09-17&nbsp;&nbsp;
          
          
          
        </div>
    </div>
  </div>



  <nav aria-label="index posts navigation">
    <ul class="pagination pg-blue justify-content-center mt-5">
      
      
        <li class="page-item">
          <a class="page-link" href="/page/2/#board">Next</a>
        </li>
      
    </ul>
  </nav>


              </div>
            </div>
          </div>
        </div>
      </div>
    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/popper/popper.min.js"></script>
<script src="/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="/lib/mdbootstrap/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/lib/prettify/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "LSG&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>


</body>
</html>
