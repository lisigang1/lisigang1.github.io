<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>faker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LSG的博客">
<meta name="keywords" content="javaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="faker">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="faker">
<meta property="og:description" content="LSG的博客">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="faker">
<meta name="twitter:description" content="LSG的博客">
  
    <link rel="alternate" href="/atom.xml" title="faker" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">faker</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">LSG</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-NODE的学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/21/NODE的学习笔记/" class="article-date">
  <time datetime="2019-09-21T03:17:11.858Z" itemprop="datePublished">2019-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/21/NODE的学习笔记/">NODE的学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="NODE基础知识"><a href="#NODE基础知识" class="headerlink" title="NODE基础知识"></a>NODE基础知识</h3><h3 id="node的作用"><a href="#node的作用" class="headerlink" title="node的作用"></a>node的作用</h3><blockquote>
<p><strong>应用node环境做的一些事情</strong></p>
<p>=&gt; 基于V8引擎(webkit内核)渲染和解析JS(所以它不是后台语言，他是一个工具或者环境，用来解析JS的工具或者环境= &gt;而说他是后台语言，主要原因是：我们一般会把NODE安装在服务器上，在服务器端写一些JS代码，通过NODE执行这些代码，实现服务器应该干的预言)**</p>
<p>(类似的：webview / 谷歌浏览器等)</p>
<ol>
<li>基于命令$ node xxx.js 把JS代码在NODE环境中执行</li>
<li>基于REPL模式(Read-Evaluate-Print-Loop，输入-求职-输出-循环)$ node</li>
</ol>
<p><strong>事情1：我们后期学习的webpack(自动化项目部署)就是基于node环境运行的</strong></p>
<p><strong>事情2：npm (node package manager) 是安装NODE后自带的模块管理工具，基于它可以安装和卸载对应的模块，类似的模块管理工具还有：borwer、yarn</strong></p>
<ul>
<li>npm安装模块是从npmjs.com 下载</li>
<li>borwer安装模块是从github.com 下载</li>
</ul>
</blockquote>
<h3 id="基于node-js-javascript-实现服务器端的功能操作"><a href="#基于node-js-javascript-实现服务器端的功能操作" class="headerlink" title="基于node.js (javascript)实现服务器端的功能操作"></a>基于node.js (javascript)实现服务器端的功能操作</h3><ul>
<li>后台语言：java / python / node.js / php / go / C#(asp.net)…</li>
</ul>
<p><strong>项目架构1：基于node.js构建全栈项目( 一般应用于中小型项目 )</strong><br> 客户端 JS             服务器端 NODE.JS</p>
<ol>
<li>客户端JS向服务器发送资源文件请求=》</li>
</ol>
<p>###项目架构2：基于NODE.JS构建中间层<br>=&gt;特点：单线程异步、无堵塞I/O、事件驱动<br>=&gt;node.js作为服务层，抗压和抗并发的能力还是不错的，前端做的活是JS和node.js</p>
<p> 客服端 JS             中间处理层node.js            服务器JAVA</p>
<ol>
<li>客户端发个中间层，然后中间层处理基础的业务逻辑，然后再转给后台</li>
<li>后台做数据分析和挖掘再转给中间层，中间层在做基础的业务逻辑，把最后的结果返给客户端<br>这种方式，也有可能基于node.js中间层实现跨域访问：客户端和中间层在同一个域下(同源)，基于中间层从第三方服务器上获取数据(node.js可以跨域获取数据)<blockquote>
<p>有的项目中，当客户端和服务器进行同时开发的时候，需要两端协商出(API文档)接口规范，然后由服务器端先开发出一个伪接口(或者测试接口)，但是有时候后太忙，伪接口需要前端写；基于node.js开发一套数据MOCK的后台；当项目联调的时候，再把接口切换到真实的后台上；</p>
</blockquote>
</li>
</ol>
<h3 id="项目架构3：基于node-js实现服务器渲染"><a href="#项目架构3：基于node-js实现服务器渲染" class="headerlink" title="项目架构3：基于node.js实现服务器渲染"></a>项目架构3：基于node.js实现服务器渲染</h3><p>=&gt; 客户端数据绑定后，在页面源代码中看不到绑定的内容，不利于SEOde优化推广，所以有些产品需要放弃“客服端渲染”，改为“服务器渲染” (由node.js处理)<br>客户端：最后返回给客户端的是，有结构样式<br>中间层node.js：资源文件在中间层，它也充当了web服务器<br>后台：提供数据请求API，做数据和相关业务逻辑的处理<br>  客户端              中间层node.js            后台</p>
<ol>
<li>当我们在客户端输入一个网址，向服务器发送请求</li>
<li>中间层接收到请求后，先找到资源文件例如：xxx.html等，然后向后台发送各种请求，拿到页面的每一部分需要展示的数据</li>
<li>把数据和结构样式在服务器端进行渲染=&gt;渲染出有结构和数据的页面</li>
<li>返回给客户端页面</li>
</ol>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I / O"></a>I / O</h3><ol>
<li>I: input 输入</li>
<li>O：output 输出</li>
<li>I / O一般指对文件的读写操作</li>
</ol>
<p><strong>JS在客户端浏览器中运行，能否对客户端本地的文件进行读写操作？</strong></p>
<blockquote>
<ul>
<li>答案：不能，因为要保证客户端的信息安全</li>
<li><code>&lt;input type=&#39;file&#39;/&gt;文件上传这种除外，但是这种也需要用户手动选择后才可以</code></li>
</ul>
</blockquote>
<p><strong>JS在服务器端运行(基于NODE运行)，能否对服务器端的文件进行操作？</strong></p>
<blockquote>
<ul>
<li>答案：可以</li>
<li>node赋予了JS进行 I / O 操作的能力 (内置模块：fs)</li>
</ul>
</blockquote>
<h2 id="window-amp-global"><a href="#window-amp-global" class="headerlink" title="window &amp; global"></a>window &amp; global</h2><p>在客户端浏览器中运行JS，JS全局对象是：window(提供了很多内置的属性和方法) </p>
<p><strong>在NODE中运行JS，全局对象是：global 或者 当前模块</strong></p>
<ul>
<li>process：node中进程管理属性  <ul>
<li>process.nextTick( ) 下个任务</li>
<li>process.env() 设置node全局变量</li>
</ul>
</li>
<li>Buffer  数据流格式</li>
<li>setImmediate () 立即执行(类似于setTimeout(func,0))</li>
</ul>
<p><strong>在REPL命令中输出的this是global，但是在xxx.js中输出的this是当前模块本身</strong></p>
<h3 id="基于NPM-模块管理"><a href="#基于NPM-模块管理" class="headerlink" title="基于NPM 模块管理"></a>基于NPM 模块管理</h3><ol>
<li>模块管理（安装和卸载）</li>
</ol>
<blockquote>
<p>安装在全局环境下和安装在当前项目中</p>
</blockquote>
<ul>
<li><p>全装在全局：$ npm install xxx –global （$ npm i -g xxx）</p>
</li>
<li><p>安装在本地项目中：$ npm i xxx</p>
<ul>
<li>把模块设置为开发依赖（开发中）：$ npm i xxx –save-dev</li>
<li>把模块设置为生产依赖（部署到服务器）：$ npm i xxx –save</li>
</ul>
</li>
<li><p>安装在全局和本地的区别</p>
<ul>
<li>安装在全局后对任何项目都有作用（也有可能导致版本冲突），但是只能基于命令的方式管理，不能基于CommonJS中的require导入使用（通俗说：就是不能导入到文件中基于代码来处理）<ul>
<li>$ npm root -g 查看全局安装到的目录</li>
<li>之所以可以使用命令操作，是因为在全局目录下生成了一个xxx.cmd的文件</li>
</ul>
</li>
<li>安装在本地默认不能基于命令管理，但是可以导入到文件中基于代码操作，只对当前项目有用</li>
</ul>
</li>
<li><p>在本地安装模块之前，最好先：$ npm init -y，生成package.json模块配置文件</p>
<ul>
<li><p>把安装的模块生成配置清单，存放在package.json中，后期别人需要部署项目的时候，只需要执行 $ npm i 就可以把所有的依赖项重新安装一遍 “跑环境”</p>
<ul>
<li>$ npm i 是把开发和生产依赖都安装一遍</li>
<li>$ npm i –production 只安装生产依赖的模块</li>
</ul>
</li>
<li><p>在package.json中，可以基于scripts选项配置本地可执行的脚本命令 $npm run xxx</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">	<span class="comment">//=&gt;AAA是命令，值是要做的事情</span></span><br><span class="line">	<span class="string">"AAA"</span>: <span class="string">"node xxx.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li>在配置可执行脚本命令的时候，基于process的环境变量区分开发还是生产环境 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="comment">//=&gt;set NODE_EVN=dev 设置全局环境变量（MAC下用 export NODE_EVN=dev）</span></span><br><span class="line">	<span class="string">"serve"</span>: <span class="string">"set NODE_EVN=dev&amp;&amp;node test1.js"</span>,</span><br><span class="line"> 			<span class="string">"build"</span>: <span class="string">"set NODE_EVN=pro&amp;&amp;node test1.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="commonJS模块管理机制"><a href="#commonJS模块管理机制" class="headerlink" title="commonJS模块管理机制"></a>commonJS模块管理机制</h3><blockquote>
<ol>
<li>AMD：require.js</li>
<li>CMD：sea.js</li>
<li>CommonJS：node.js</li>
<li>ES6 Module</li>
</ol>
<p><strong>这些模块化思想，规定了在JS中我们的模块如何的创建，如何的导入以及如何导出</strong></p>
</blockquote>
<ol>
<li><strong>内置模块</strong></li>
</ol>
<blockquote>
<ol>
<li>http/https：创建和管理服务的模块</li>
<li>fs ：给予JS进行 I / O操作的</li>
<li>url ：解析 URL地址的</li>
<li>path ：管理路径</li>
</ol>
</blockquote>
<ol start="2">
<li><p><strong>第三方模块：基于npm安装，别人写好供我们使用的</strong></p>
<ul>
<li>less =&gt;可以不用</li>
<li>mime</li>
<li>qs</li>
<li>express</li>
<li>express-session</li>
<li>body-parser</li>
<li>…</li>
</ul>
</li>
<li><p><strong>自定义模块：自己写的模块</strong></p>
</li>
</ol>
<h3 id="node中的模块管理"><a href="#node中的模块管理" class="headerlink" title="node中的模块管理"></a>node中的模块管理</h3><ol>
<li>在node环境下，我们每创建一个JS都相当于创建了一个新模块：而那个模块中的方法也都是模块的私有方法，不同模块之间的同名方法不会有任何的冲突</li>
<li>module.exprots就是NODE天生自带的用来导出模块中方法的方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;导出需要被外部模块所调用的方法</span></span><br><span class="line"><span class="built_in">module</span>.exprots就是NODE天生自带的用来导出模块中方法的方式</span><br><span class="line"><span class="built_in">module</span>.exprots=&#123;</span><br><span class="line">    <span class="comment">//=&gt;这些属性方法就是需要暴露给外面使用的</span></span><br><span class="line">    xxx:xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>require是NODE天生提供的用来导入模块的方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;语法</span></span><br><span class="line"><span class="keyword">let</span> [模块名] = <span class="built_in">require</span> ([模块的地址])</span><br><span class="line"><span class="comment">//=&gt;例如</span></span><br><span class="line"><span class="comment">//1)可以省略.js后缀名</span></span><br><span class="line"><span class="comment">//2)如果是调用自己定义的模块，则需要加/(根目录) ./(当前目录) ../(上级目录) 这三个中的某一个</span></span><br><span class="line"><span class="comment">//3)不加上述地址，则先找第三方模块(安装在自己本地的)，如果没有安装，则找NODE中的内置模块，如果再没有，则报错</span></span><br><span class="line"><span class="keyword">let</span> A = <span class="built_in">require</span>(<span class="string">'./A'</span>);</span><br><span class="line"><span class="keyword">let</span> qs =<span class="built_in">require</span>(<span class="string">'qs'</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>导入模块是同步的(没导入完成，后面的事情是不处理的)；每一次导入模块都是把导入的模块中的JS代码从上到下执行一遍(只执行一遍)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/21/NODE的学习笔记/" data-id="ck0v9359q00092sccmqzc5ngp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-存储的作用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/存储的作用/" class="article-date">
  <time datetime="2019-09-19T11:51:48.099Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/存储的作用/">存储的作用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="存储的作用"><a href="#存储的作用" class="headerlink" title="存储的作用"></a>存储的作用</h3><h3 id="什么时候会用到本地存储？本地存储的作用？"><a href="#什么时候会用到本地存储？本地存储的作用？" class="headerlink" title="什么时候会用到本地存储？本地存储的作用？"></a>什么时候会用到本地存储？本地存储的作用？</h3><ol>
<li>记住用户名和密码（或者自动登录）</li>
<li>未登录状态下，加入购物车的信息一般也先存储在本地，当登录后，把信息存储到服务器上（目的是多平台数据共享）</li>
<li>对于非实时刷新数据，我们可以在从服务器把数据获取到后，临时存储在本地（设置有效时间），在有效时间内页面刷新，不再重新从服务器获取数据，而是读取本地数据；超过有效时间重新从服务器拉取…  “前端性能优化的一点”</li>
<li>还能实现同一个网站不同页面之间的信息共享和通信</li>
</ol>
<h3 id="本地存储到底存储在哪了？"><a href="#本地存储到底存储在哪了？" class="headerlink" title="本地存储到底存储在哪了？"></a>本地存储到底存储在哪了？</h3><ol>
<li><p>本地存储是受浏览器限制的，例如：在谷歌中存储的数据，在IE中获取不到 </p>
</li>
<li><p>受源(域)的限制，例如：都是用谷歌浏览器，我在京东下存储的数据，在百度中是获取不到的</p>
</li>
<li><p>本地存储的信息在控制台中可以查看到（而且是明文存储），所以敏感的数据尽可能不要存储在本地，非要存储也要做安全处理（例如：加密）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- setItem([key],[value]) 存储信息 </span><br><span class="line">- getItem([key]) 获取信息</span><br><span class="line">- removeItem([key]) 移除某一项信息</span><br><span class="line">- clear() 清除所有存储的信息</span><br><span class="line">=&gt;向本地存储的信息都是STRING字符串格式</span><br><span class="line">=&gt;localStorage是持久化存储在客户端本地的（除非手动清除或者浏览器卸载等，否则一直存储下来，没有过期时间）</span><br><span class="line"> =&gt;sessionStorage会话存储（当前页面刷新，存储信息还在，但是只要页面一关闭，所有会话存储的信息都会消失）</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 设置cookie  =&gt;jquery.cookie.js</span><br><span class="line"></span><br><span class="line"> <span class="built_in">document</span>.cookie=<span class="string">"[key]=[value];..."</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// $.cookie('username', '珠峰培训');</span></span><br><span class="line"><span class="comment">// console.log($.cookie('username'));</span></span><br><span class="line"><span class="comment">// $.removeCookie('username');</span></span><br><span class="line"> <span class="comment">/* $.cookie('username', 'zhufeng', &#123;</span></span><br><span class="line"><span class="comment">expires: new Date(new Date().getTime() + 30 * 24 * 60 * 60 * 1000)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   &#125;);</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="COOKIE-VS-LOCALSTORAGE"><a href="#COOKIE-VS-LOCALSTORAGE" class="headerlink" title="COOKIE VS LOCALSTORAGE"></a>COOKIE VS LOCALSTORAGE</h3><ol>
<li>大小限制：一般浏览器允许一个源下COOKIE最多存储8KB，而LOCALSTORAGE被允许存储最大的长度限制是5MB</li>
<li>2.兼容性：COOKIE兼容所有浏览器，而LOCALSTORAGE是H5中新增的，不兼容IE低版本浏览器（IE6~8）</li>
<li>稳定性：COOKIE有过期时间，但是一般不等到时间可能就没了（例如：清除浏览器的缓存或者历史信息、安全卫士在清理电脑垃圾等操作时，都有可能会把存储的COOKIE给清除掉），但是这些操作对LOCALSTORAGE没有影响</li>
<li>有时候浏览器会开启无痕浏览或者隐私模式，此时无法设置COOKIE，但是可以设置LOCALSTORAGE的信息</li>
<li>和服务器端的猫腻：COOKIE总是会和服务器中的SESSION眉来眼去（客户端和服务器端交互的时候，COOKIE信息会传来传去），而LOCALSTORAGE不屑于和他们同流合污（LOCALSTORAGE和服务器没有必然的联系，是单纯的本地存储）</li>
<li>存储时间：COOKIE有过期时间，而LOCALSTORAGE是持久存储</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/存储的作用/" data-id="ck0v9358i00022scc3d8sglgm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一个倒计时案例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/一个倒计时案例/" class="article-date">
  <time datetime="2019-09-19T11:51:40.546Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/一个倒计时案例/">一个倒计时案例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一个倒计时案例"><a href="#一个倒计时案例" class="headerlink" title="一个倒计时案例"></a>一个倒计时案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new Date()获取客户端本地当前时间（不能拿它做重要依据，因为用户可以随意修改）</span></span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * 倒计时抢购需要从服务器获取当前时间  AJAX</span></span><br><span class="line"><span class="comment">		 *    问题：时间差（从服务器把时间给客户端，到客户端获取到这个信息，中间经历的时间就是时间差，而时间差是不可避免的，我们应尽可能减少这个误差）</span></span><br><span class="line"><span class="comment">		 *    - 从响应头获取时间（AJAX异步）</span></span><br><span class="line"><span class="comment">		 *    - 基于HEAD请求（只获取响应头信息）</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">let</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019/09/14 13:27:00'</span>),</span><br><span class="line">			now = <span class="literal">null</span>,</span><br><span class="line">			timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//=&gt;从服务器获取时间：获取到时间后再做其他的事情</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest;</span><br><span class="line">			xhr.open(<span class="string">'HEAD'</span>, <span class="string">'json/data.json'</span>, <span class="literal">true</span>);</span><br><span class="line">			xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="regexp">/^(2|3)\d&#123;2&#125;$/</span>.test(xhr.status)) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span> (xhr.readyState === <span class="number">2</span>) &#123;</span><br><span class="line">					now = <span class="keyword">new</span> <span class="built_in">Date</span>(xhr.getResponseHeader(<span class="string">'Date'</span>));</span><br><span class="line">					callback &amp;&amp; callback();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			xhr.send(<span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//=&gt;开启倒计时模式</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">computed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> spanTime = target - now;</span><br><span class="line">			<span class="keyword">if</span> (spanTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//=&gt;到抢购时间：结束定时器</span></span><br><span class="line">				clearInterval(timer);</span><br><span class="line">				timer = <span class="literal">null</span>;</span><br><span class="line">				box.innerHTML = <span class="string">"开抢~~"</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor(spanTime / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">			spanTime -= hours * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">			<span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor(spanTime / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">			spanTime -= minutes * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">			<span class="keyword">let</span> seconds = <span class="built_in">Math</span>.floor(spanTime / <span class="number">1000</span>);</span><br><span class="line">			box.innerHTML =</span><br><span class="line">				<span class="string">`距离抢购还剩 <span class="subst">$&#123;hours&lt;<span class="number">10</span>?<span class="string">'0'</span>+hours:hours&#125;</span>:<span class="subst">$&#123;minutes&lt;<span class="number">10</span>?<span class="string">'0'</span>+minutes:minutes&#125;</span>:<span class="subst">$&#123;seconds&lt;<span class="number">10</span>?<span class="string">'0'</span>+seconds:seconds&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//=&gt;每一次计算完，我们需要让NOW在原来的基础上加上一秒（第一次从服务器获取到时间，后期直接基于这个时间自己加即可，不要每隔一秒重新从服务器拿）</span></span><br><span class="line">			now = <span class="keyword">new</span> <span class="built_in">Date</span>(now.getTime() + <span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		func(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">//=&gt;已经从服务器获取时间了</span></span><br><span class="line">			computed();</span><br><span class="line">			timer = setInterval(computed, <span class="number">1000</span>);</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/一个倒计时案例/" data-id="ck0v9358r00042sccmxckuirr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-权限校验从用户成功登陆开始" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/权限校验从用户成功登陆开始/" class="article-date">
  <time datetime="2019-09-19T11:30:00.004Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/权限校验从用户成功登陆开始/">权限校验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="权限校验从用户成功登陆开始"><a href="#权限校验从用户成功登陆开始" class="headerlink" title="权限校验从用户成功登陆开始"></a>权限校验从用户成功登陆开始</h3><p>​    1. 服务器校验</p>
<blockquote>
<ol>
<li>客户端做某个操作的时候=&gt;服务器根据登陆者的角色，进行权限校验，返回给客户端是否可以操作 =&gt; 服务器返回给客户端能否操作的标识</li>
<li>或者不确定哪些内容用户可以看的，都向服务器发请求，由服务器告知我们，那些需要展示</li>
</ol>
<p>弊端：服务器要处理的请求和对应的压力较大</p>
<p>优势：安全</p>
</blockquote>
<ol start="2">
<li>客户端校验</li>
</ol>
<blockquote>
<p>当用户登录成功后，服务器会把该用户拥有的权限，返回给客户端(或者客户端可以基于某个API接口从服务器获取权限)</p>
<ol>
<li><p>客户端根据获取的权限校验标识，控制那些显示，那些隐藏，或者进行某些操作的时候进行对应的提示</p>
</li>
<li><p>问题：在某个页面中获取的权限校验码，需要在其它页面使用 =&gt; 我们一般基于本地存储完成的(VUE/REACT中式存储到redux/vuex中的)，如果服务器支持获取权限的接口，也可以每次都从服务器重新获取</p>
<p>优势：不需要频繁向服务器发送请求，获取校验码后，一切判断客户端来处理，这样减少业务逻辑的复杂度，也减轻了服务器的压力；而且每次验证是否存在权限的速度也快…</p>
<p>弊端：因为客户端本地校验(有可能还要把信息存储在客户端本地)，容易导致权限校验的泄露个篡改，不是很安全 =&gt;所有真实项目中，对于重要的操作权限，服务器会进行二次校验(在客户端每次业务逻辑请求的时候，服务器就做了校验)</p>
</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/权限校验从用户成功登陆开始/" data-id="ck0v9358v00052scclb77ne3e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX核心处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/AJAX核心处理/" class="article-date">
  <time datetime="2019-09-19T10:33:07.290Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/AJAX核心处理/">AJAX的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="AJAX核心处理"><a href="#AJAX核心处理" class="headerlink" title="AJAX核心处理"></a>AJAX核心处理</h3><blockquote>
<p> 支持的参数配置项</p>
<ol>
<li>url</li>
<li>method:’GET’</li>
<li>data:null</li>
<li>dataType:’json’</li>
<li>async:true</li>
<li>cache:true</li>
<li>success:null</li>
<li>error:null</li>
<li>headers:null</li>
<li>timeout:null</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ==AJAX处理的核心== */</span></span><br><span class="line"><span class="keyword">let</span> regGET = <span class="regexp">/^(GET|DELETE|HEAD|OPTIONS)$/i</span>;</span><br><span class="line"><span class="keyword">let</span> defaults = &#123;</span><br><span class="line">	url: <span class="string">''</span>, <span class="comment">//=&gt;请求的API接口地址</span></span><br><span class="line">	method: <span class="string">'GET'</span>, <span class="comment">//=&gt;请求方式 GET/POST/DELETE/PUT/HEAD/OPTIONS</span></span><br><span class="line">	data: <span class="literal">null</span>, <span class="comment">//=&gt;传递给服务器的信息：支持格式STRING和OBJECT，如果是OBJECT，我们需要把其处理为x-www-form-urlencoded格式；GET请求是把信息作为问号参数传递给服务器，POST请求是放到请求主体中传递给服务器；</span></span><br><span class="line">	dataType: <span class="string">'JSON'</span>, <span class="comment">//=&gt;把服务器返回结果处理成为对应的格式 JSON/TEXT/XML</span></span><br><span class="line">	<span class="keyword">async</span>: <span class="literal">true</span>, <span class="comment">//=&gt;是否异步请求</span></span><br><span class="line">	cache: <span class="literal">true</span>, <span class="comment">//=&gt;只对GET请求有作用：设置为FALSE,在URL的末尾加随机数来清除缓存</span></span><br><span class="line">	timeout: <span class="literal">null</span>, <span class="comment">//=&gt;超时时间</span></span><br><span class="line">	headers: <span class="literal">null</span>, <span class="comment">//=&gt;设置请求头信息（请求头信息不能是中文，所以我们需要为其编码）</span></span><br><span class="line">	success: <span class="literal">null</span>, <span class="comment">//=&gt;从服务器获取成功后执行 把获取的结果、状态信息、XHR传递给它</span></span><br><span class="line">	error: <span class="literal">null</span> <span class="comment">//=&gt;获取失败后执行 把错误信息传递给它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>jQuery.AJAX</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> *    $.ajax() 基于原生JS的AJAX四步操作进行封装</span><br><span class="line">*    $.ajax([URL],[OPTIONS])</span><br><span class="line">*    $.ajax([OPTIONS])  URL在配置项中（推荐）</span><br><span class="line">*    $.<span class="keyword">get</span>/post/getJSON/getScript()</span><br><span class="line">*    ......</span><br><span class="line">* 配置项信息</span><br><span class="line">*    url:请求的API接口地址</span><br><span class="line">*    method:HTTP请求方式，默认GET</span><br><span class="line">*    data:传递给服务器的信息，默认null（可以是字符串，可以是对象，而且如果GET系列请求，JQ会自动把信息拼接到URL的末尾，基于问号传参传递给服务器；如果是POST请求，JQ会基于请求主体，把信息传递给服务器）</span><br><span class="line">*    dataType:预设服务器返回的结果格式（服务器返回的一般都是JSON格式的字符串，如果我们设置了DATA-TYPE，JQ会根据设置的类型，把服务器返回的结果处理为对应的格式），支持的内容text / json / xml / html / script / jsonp(跨域) =&gt;不影响服务器返回的结果，只是把服务器返回的结果进行二次处理</span><br><span class="line">*    async:是否为异步操作，默认是TRUE，代表异步操作</span><br><span class="line">*    cache:缓存处理，只对GET系列请求有作用，默认是TRUE不处理缓存，当我们设置FALSE后，JQ帮我们在URL的末尾设置一个随机数</span><br><span class="line">*    contentType:设置传递给服务器内容的格式类型 默认是"application/x-www-form-urlencoded"</span><br><span class="line">*        客户端传递给服务器信息的格式（类型一般都是字符串），常用的：</span><br><span class="line">*        form-data表单数据：JSON格式 '&#123;<span class="string">"name"</span>:<span class="string">"xxx"</span>,<span class="string">"lx"</span>:<span class="number">1</span>&#125;<span class="string">'</span></span><br><span class="line"><span class="string">*        x-www-form-urlencoded：name=xxx&amp;lx=1</span></span><br><span class="line"><span class="string">*        raw：纯文本格式</span></span><br><span class="line"><span class="string">*    headers:设置请求头信息，他是一个对象</span></span><br><span class="line"><span class="string">*    timeout:设置超时的时间</span></span><br><span class="line"><span class="string">*    success:回调函数，当数据请求成功执行，方法中的参数就是从服务器获取的结果</span></span><br><span class="line"><span class="string">*    error:回调函数，数据请求失败执行，方法中的参数是错误信息</span></span><br></pre></td></tr></table></figure>

<h3 id="AJAX状态码"><a href="#AJAX状态码" class="headerlink" title="AJAX状态码"></a>AJAX状态码</h3><p>xhr.readyState  获取状态码</p>
<ul>
<li>0 =&gt;UNSENT    未发送</li>
<li>1 =&gt;OPENED    已经打开执行了xhr.open</li>
<li>2 =&gt;HEADERS_RECEIVED  响应头已经返回</li>
<li>3 =&gt;LOADING  等待服务器返回响应内容</li>
<li>4 =&gt;DONE  响应主体已经返回给客户端 结束</li>
</ul>
<p>XHR的属性和方法</p>
<blockquote>
<ol>
<li>xhr.response / xhr.responseText / xhr.responseXML</li>
<li>xhr.status / xhr.statusText =&gt;状态码</li>
<li>xhr.timeout =&gt; 超时时间</li>
<li>xhr.withCredentials =&gt; 用户是否允许带证书</li>
<li>xhr.abort()=&gt; 手动中断AJAX请求</li>
<li>xhr.getAllResponseHeaders() =&gt;获取所有头的响应信息</li>
<li>xhr.getResponseHeader([key]) =&gt; 一个个获取头</li>
<li>xhr.open() =&gt; 请求方式 (GET、POST)</li>
<li>xhr.overrideMimeType() =&gt;重写mme类型 mme是一种框架思想</li>
<li>xhr.send() =&gt; 发送请求</li>
<li>xhr.setRequestHeader() =&gt;设置请求头</li>
</ol>
</blockquote>
<h3 id="AJAX同步、异步"><a href="#AJAX同步、异步" class="headerlink" title="AJAX同步、异步"></a>AJAX同步、异步</h3><ol>
<li>AJAX同步</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;AJAX的同步</span></span><br><span class="line"><span class="comment">/* let xhr = new XMLHttpRequest;</span></span><br><span class="line"><span class="comment">xhr.open('GET', 'json/data.json', false);</span></span><br><span class="line"><span class="comment">xhr.onreadystatechange = function () &#123;</span></span><br><span class="line"><span class="comment">	console.log(xhr.readyState); //=&gt;4 使用AJAX同步编程，不能在状态码为2的时候获取到响应头的信息，但是状态码为4的时候也是可以获取到头和主体信息</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">xhr.send(null); */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>AJAX异步</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* let xhr = new XMLHttpRequest;</span></span><br><span class="line"><span class="comment">	xhr.open('GET', 'json/data.json');</span></span><br><span class="line"><span class="comment">	xhr.send(null);</span></span><br><span class="line"><span class="comment">	xhr.onreadystatechange = function () &#123;</span></span><br><span class="line"><span class="comment">		console.log(xhr.readyState); //=&gt;2 3 4</span></span><br><span class="line"><span class="comment">	&#125; */</span></span><br></pre></td></tr></table></figure>

<h3 id="AJAX的四步"><a href="#AJAX的四步" class="headerlink" title="AJAX的四步"></a>AJAX的四步</h3><ol>
<li><p>创建AJAX</p>
<ul>
<li>let xhr = new XMLHttpRequest  ;(IE 下用new ActivexObject())</li>
</ul>
</li>
<li><p>打开URL(配置发送请求的信息)</p>
<ul>
<li>method：HTTP请求方式</li>
<li>URL：请求地址(API接口地址)</li>
<li>async：设置同步异步，默认true异步，false同步</li>
<li>USER-NAME：传递给服务器的用户名</li>
<li>USER-PASS：传递给服务器的密码</li>
</ul>
</li>
<li><p>监听AJAX状态，在状态为X的时候，获取服务器响应的内容</p>
<ul>
<li><p>AJAX状态码：0 1 2 3 4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState===<span class="number">4</span> &amp;&amp; <span class="regexp">/^(2|3)\d&#123;2&#125;$/</span>.test(xhr.status))&#123;</span><br><span class="line">		<span class="keyword">let</span> result = xhr.responseText;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>发送请求</p>
<ul>
<li>xhr.send(null)=&gt;内面试请求主体的内容</li>
</ul>
</li>
</ol>
<h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><ol>
<li><p>GET系列请求</p>
<ul>
<li>GET</li>
<li>DELETE 一般应用于告诉服务器，从服务器上删除点东西</li>
<li>HEAD 只想获取响应头内容，告诉服务器响应主体内容不要了</li>
<li>OPTIONS 试探性请求，发个请求给服务器，看看服务器能不能接收到，能不能返回</li>
</ul>
</li>
<li><p>POST系列请求</p>
<ul>
<li>POST</li>
</ul>
</li>
<li><p>PUT 和DELETE对应，一般是想让服务器把我传递的信息存储到服务器上（一般应用于文件和大型数据内容）</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/AJAX核心处理/" data-id="ck0v9357p00002sccjwhtje6m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器和客户端渲染机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/服务器和客户端渲染机制/" class="article-date">
  <time datetime="2019-09-19T04:31:34.037Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/服务器和客户端渲染机制/">服务器和客户端</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="服务器和客户端渲染机制"><a href="#服务器和客户端渲染机制" class="headerlink" title="服务器和客户端渲染机制"></a>服务器和客户端渲染机制</h2><h4 id="服务器接收到请求后"><a href="#服务器接收到请求后" class="headerlink" title="服务器接收到请求后"></a>服务器接收到请求后</h4><blockquote>
<ol>
<li><p>找到对应的页面，获取到页面的代码</p>
</li>
<li><p>再根据需求从数据库中获取到需要动态展示的数据</p>
</li>
<li><p>把页面和数据混合在一起进行渲染，声称有结构有内容的完整页面</p>
<p>= &gt; 服务器渲染</p>
<ol start="4">
<li>把渲染玩的页面返回给客户端</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="服务器渲染的特点"><a href="#服务器渲染的特点" class="headerlink" title="服务器渲染的特点"></a>服务器渲染的特点</h3><blockquote>
<ol>
<li>我们看到的内容都是在服务器端渲染完的(JSP、PHP、ASP、ASP.NET、NODE…)，客户端只是把所有渲染好的内容呈现在页面中而已；然而我们第一次渲染完，页面中的某部分数据需要更新了，我们需要让服务器整体重新的渲染一次，把最新的页面(包含最新的数据)返回给客户端，客户端只能整体刷新页面展示最新的内容 = &gt;”全局刷新”性能和体验等都非常差，而且服务器压力也很大…</li>
<li>如果服务器性能比较高，页面展现出来的速度会快一些，因为只要从服务器拿到内容，一切信息都已经准备好了</li>
<li>由于内容在服务器端已经渲染好了，所以页面渲染完成后，在页面的源代码中哪个都可以看到内容，有利于SEO搜索引擎优化</li>
</ol>
</blockquote>
<h3 id="客户端渲染数据的内容"><a href="#客户端渲染数据的内容" class="headerlink" title="客户端渲染数据的内容"></a>客户端渲染数据的内容</h3><blockquote>
<ol>
<li>可以实现页面中内容的局部刷新，而且渲染的操作交给客户端来做=&gt;体验好、减轻了服务器压力</li>
<li>而且开始可以只把部分区域内容的数据获取到，滚到某个区域后，在请求对应的数据也可以，实现数据的分批异步加载，提高性能体验</li>
<li>由于客户端渲染的内容没有出现在页面的源代码中，不利于SEO优化</li>
</ol>
</blockquote>
<p><img src="C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568867487011.png" alt="1568867487011"></p>
<h3 id="当代项目开发的整个架构模式"><a href="#当代项目开发的整个架构模式" class="headerlink" title="当代项目开发的整个架构模式"></a>当代项目开发的整个架构模式</h3><ol>
<li>纯服务器渲染(需要做SEO优化或者是技术氛围问题)</li>
<li>混编模式：部分内容为服务器渲染，部分内容是客户端渲染  =&gt;常见的<ul>
<li>骨架屏：首屏内容为服务器渲染(目的是让页面一打开，就把首屏内容加载出来，前提服务器得给力)，其余屏内容都是客户端基于AJAX在逐一获取到的，对于表单提交等数据交互操作也是客户端基于AJAX等操作为主(局部刷新)</li>
</ul>
</li>
<li>完全客户端和服务器端分离开发 =&gt; 目前最常见的(推荐的)<ul>
<li>vue \ react \ jQ</li>
</ul>
</li>
<li>把vue和react在服务器端基于node来渲染 =&gt;服务器渲染</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/服务器和客户端渲染机制/" data-id="ck0v9359100062scc5oufz5j8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-URL地址经历了什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/URL地址经历了什么/" class="article-date">
  <time datetime="2019-09-19T04:16:23.958Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/URL地址经历了什么/">URL都经历了什么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="URL地址经历了什么"><a href="#URL地址经历了什么" class="headerlink" title="URL地址经历了什么"></a>URL地址经历了什么</h2><h3 id="当我们输入URL按下Enter键经历了什么"><a href="#当我们输入URL按下Enter键经历了什么" class="headerlink" title="当我们输入URL按下Enter键经历了什么"></a>当我们输入URL按下Enter键经历了什么</h3><ol>
<li><p>URL地址解析</p>
</li>
<li><p>DNS域名解析</p>
</li>
<li><p>和服务器建立TCP链接</p>
</li>
<li><p>把客户端信息传递给服务器(发送HTTP请求)</p>
</li>
<li><p>服务器得到并处理(HTTP响应内容)</p>
</li>
<li><p>客户端渲染服务器返回的内容</p>
</li>
<li><p>和服务断开TCP链接</p>
<p>### </p>
<h3 id="服务器端和客户端"><a href="#服务器端和客户端" class="headerlink" title="服务器端和客户端"></a>服务器端和客户端</h3><blockquote>
<p>客户端：可以向服务器发请求，并接收返回的内容进行处理<br>服务器端：能够接收客户端请求，并且把相关资源信息返回给客户端的</p>
</blockquote>
<h3 id="URI-URL-URN"><a href="#URI-URL-URN" class="headerlink" title="URI/URL/URN"></a>URI/URL/URN</h3><ul>
<li>URL（Uniform Resource Locator）：统一资源定位符，根据这个地址能找到对应的资源</li>
<li>URN（Uniform Resource Name）：统一资源名称，一般指国际上通用的（标准的）一些名字（例如：国际统一发版的编号）</li>
<li>URI（Uniform Resource Identifier）：统一资源标识符，URL和URN是URI的子集</li>
</ul>
<h3 id="一个完整的URL所包含的内容"><a href="#一个完整的URL所包含的内容" class="headerlink" title="一个完整的URL所包含的内容"></a>一个完整的URL所包含的内容</h3><blockquote>
<p><a href="http://www.zhufengpeixun.cn:80/stu/index.html?from=wx&amp;lx=1#zhenyu" target="_blank" rel="noopener">http://www.zhufengpeixun.cn:80/stu/index.html?from=wx&amp;lx=1#zhenyu</a></p>
</blockquote>
<ul>
<li>协议（http://）：传输协议就是，能够把客户端和服务器端通信的信息，进行传输的工具（类似于快递小哥）<ul>
<li>http 超文本传输协议，除了传递文本，还可以传递媒体资源文件（或者流文件）及XML格式数据</li>
<li>https 更加安全的http，一般涉及支付的网站都要采用https协议（s:ssl 加密传输）</li>
<li>ftp 文件传输协议（一般应用于把本地资源上传到服务器端）</li>
</ul>
</li>
<li>域名（<a href="http://www.zhufengpeixun.cn）：一个让用户方便记忆的名字（不通过域名，直接用服务器的外网IP也能访问到服务器，但是外网IP很难被记住）" target="_blank" rel="noopener">www.zhufengpeixun.cn）：一个让用户方便记忆的名字（不通过域名，直接用服务器的外网IP也能访问到服务器，但是外网IP很难被记住）</a><ul>
<li>顶级域名 qq.com</li>
<li>一级域名 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a></li>
<li>二级域名 sports.qq.com</li>
<li>三级域名 kbs.sports.qq.com</li>
<li>.com 国际域名</li>
<li>.cn 中文域名</li>
<li>.com.cn</li>
<li>.edu 教育</li>
<li>.gov 政府</li>
<li>.io  博客</li>
<li>.org 官方组织</li>
<li>.net 系统类</li>
</ul>
</li>
<li>端口号（:80）：端口号的取值范围0~65535，用端口号来区分同一台服务器上的不同项目<ul>
<li>http默认端口号：80</li>
<li>https默认端口号：443</li>
<li>ftp默认端口号：21</li>
<li>如果项目采用的就是默认端口号，我们在书写地址的时候，不用加端口号，浏览器在发送请求的时候会帮我们默认给加上</li>
</ul>
</li>
<li>请求资源路径名称（/stu/index.html）<ul>
<li>默认的路径或者名称 （xxx.com/stu/ 不指定资源名，服务器会找默认的资源，一般默认资源名是default.html、index.html…当然这些可以在服务器端自己配置）</li>
<li>注意伪URL地址的处理（URL重写技术是为了增加SEO搜索引擎优化的，动态的网址一般不能被搜索引擎收录，所以我们要把动态网址静态化，此时需要的是重写URL）<br><a href="https://item.jd.hk/2688449.html" target="_blank" rel="noopener">https://item.jd.hk/2688449.html</a> =&gt; <a href="https://item.jd.hk/index.php?id=2688449" target="_blank" rel="noopener">https://item.jd.hk/index.php?id=2688449</a></li>
</ul>
</li>
<li>问号传参信息（?from=wx&amp;lx=1）<ul>
<li>客户端想把信息传递给服务器，有很多的方式<ul>
<li>URL地址问号传参</li>
<li>请求报文传输（请求头和请求主体）</li>
</ul>
</li>
<li>也可以不同页面之间的信息交互，例如:从列表到详情</li>
</ul>
</li>
<li>HASH值（#zhenyu）<ul>
<li>也能充当信息传输的方式</li>
<li>锚点定位</li>
<li>基于HASH实现路由管控（不同的HASH值，展示不同的组件和模块）</li>
</ul>
</li>
</ul>
<h3 id="DNS服务器域名解析"><a href="#DNS服务器域名解析" class="headerlink" title="DNS服务器域名解析"></a>DNS服务器域名解析</h3><blockquote>
<p>DNS服务器：域名解析服务器，在服务器上存储着 域名&lt;=&gt;服务器外网IP 的相关记录<br>而我们发送请求时候所谓的DNS解析，其实就是根据域名，在DNS服务器上查找到对应服务器的外网IP </p>
</blockquote>
<p><strong>DNS优化</strong></p>
<ul>
<li>DNS缓存（一般浏览器会在第一次解析后，默认建立缓存，时间很短，只有一分钟左右）</li>
<li>减少DNS解析次数（一个网站中我们需要发送请求的域名和服务器尽可能少即可）</li>
<li>DNS预获取(dns-prefetch)：在页面加载开始的时候，就把当前页面中需要访问其他域名(服务器)的信息进行提前DNS解析，以后加载到具体内容部分可以不用解析了    </li>
</ul>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><ul>
<li>请求报文：所有经过传输协议，客户端传递给服务器的内容，都被成为请求报文<ul>
<li>起始行</li>
<li>请求头（请求首部）</li>
<li>请求主体</li>
</ul>
</li>
<li>响应报文：所有经过传输协议，服务器返回给客户端的内容，都被成为响应报文<ul>
<li>HTTP状态码</li>
<li>响应头</li>
<li>响应主体</li>
</ul>
</li>
<li>HTTP报文：请求报文+响应报文</li>
</ul>
<p>=&gt;谷歌浏览器F12  =&gt;Network（所有客户端和服务器端的交互信息在这里都可以看到） =&gt;点击某一条信息，在右侧可以看到所有的HTTP报文信息</p>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><blockquote>
<p>1~5开头，三位数字</p>
</blockquote>
<ul>
<li>200 OK：成功</li>
<li>201 CREATED：一般应用于告诉服务器创建一个新文件，最后服务器创建成功后返回的状态码</li>
<li>204 NO CONTENT：对于某些请求（例如：PUT或者DELETE），服务器不想处理，可以返回空内容，并且用204状态码告知</li>
<li>301 Moved Permanently：永久重定向（永久转移）</li>
<li>302 Moved Temporarily：临时转移，很早以前基本上用302来做，但是现在主要用307来处理这个事情，307的意思就是临时重定向Temporary Redirect  =&gt;主要用于：服务器的负载均衡等</li>
<li>304 Not Modified：设置HTTP的协商缓存</li>
<li>400 Bad Request：传递给服务器的参数错误</li>
<li>401 Unauthorized：无权限访问</li>
<li>404 Not Found：请求地址错误</li>
<li>500 Internal Server Error：未知服务器错误</li>
<li>503 Service Unavailable：服务器超负荷</li>
</ul>
<p>遇到link/img/audio/video等是异步去加载资源信息（浏览器分配一个新的线程去加载，主线程继续向下渲染页面）,如果遇到的是script或者@import，则让主线程去加载资源信息（同步），加载完成信息后，再去继续渲染页面；</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/URL地址经历了什么/" data-id="ck0v9358m00032sccktf09ma5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-点击登录按钮经历了什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/18/点击登录按钮经历了什么/" class="article-date">
  <time datetime="2019-09-18T07:06:23.836Z" itemprop="datePublished">2019-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/18/点击登录按钮经历了什么/">点击登录按钮中间经历了什么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="点击登录按钮经历了什么"><a href="#点击登录按钮经历了什么" class="headerlink" title="点击登录按钮经历了什么"></a>点击登录按钮经历了什么</h2><blockquote>
<p>第一步：<br>   获取用户输入的用户名和密码（表单验证）</p>
<p> 第二步：<br>   基于ajax向服务器发请求，把用户名和密码传递给服务器通过post</p>
<p> 第三步：服务器接收到信息后，把密码二次加密，在收到数据库中查找是否存在用户名和密码相匹配的人员，<br>   如果找不到，只需要告诉客户端，用户名和密码不匹配<br>   如果找到了，“在服务端记录当前用户的登录态”<br>   \1. 在服务器设置一个session （connect_sid)存储当前用户已经登录了登录态<br>   \2. 获取当前用户能操作的权限信息，连同登录成功的信息一并返回给客户端</p>
<p>第四步： 把最后操作的结果告诉客户端</p>
<p>第五步：客户端获取信息后，进行相关操作</p>
</blockquote>
<h3 id="信息加密-密码都是不可逆转的"><a href="#信息加密-密码都是不可逆转的" class="headerlink" title="信息加密(密码都是不可逆转的)"></a>信息加密(密码都是不可逆转的)</h3><ol>
<li><p>可逆转加密（按照规则加密，再按照规则解密）</p>
</li>
<li><p>不可逆转加密（一旦进行加密，不能再解密）MD5 =&gt;密码一定是不可逆转的。增加用户的时候，把用户密码进行MD5加密，把加密的结果存储到数据库中，登录的时候把输入的密码还是MD5加密，拿加密的结果和之前存储的结果进行匹配，如果一样，则说明两次输入的原始密码是一致。<br>&gt; 为了防止用户输入的密码过于简单（当然可以限制密码的规则）我们服务器需要把MD5加密的结果进行二次或者多次加密（例如：MD5加密的结果是32位，我们去掉前四位，去掉后四位，把剩下的反序）<br>### 登录步骤</p>
</li>
</ol>
<h3 id="进入首页"><a href="#进入首页" class="headerlink" title="进入首页"></a>进入首页</h3><p>进入首页<br>   第一步：验证登录态（重新向服务器发送请求，由服务器告知我们是否登录）<br>   第二步，服务器校验登录态只需要查看是否有session信息即可</p>
<ol>
<li>如果我们在服务器设置了session ,则会生成一个和当前客户端建立链接的唯一标识 connect_sid</li>
<li>服务器在给客户端反馈信息的时候，会把这个标识通过响应头 set-cookie传递给客户端：客户端浏览器拿到信息后，只要发现响应头中有set-cookie，就会在客户端本地种一个不可修改的cookie 信息，存储的信息就是connect_sid </li>
<li>以后客户端再向服务器发请求，浏览器会默认的在请求头中，就会把存储的connect_sid 传递给服务器，服务器拿到请求后，就知道是哪个客户端了，从而找到了之前存储的session信息；<br>服务器设置的session的过期时间，一般是和客户端的cookie的存储时间一致的</li>
</ol>
<p><img src="C:%5CUsers%5Cpc%5CDesktop%5C%E8%80%81%E5%B8%88%E7%9A%84%E7%AC%94%E8%AE%B0%5C201908%5C%E7%AC%AC%E4%B8%83%E5%91%A8%5C%E4%BC%81%E4%B8%9AOA%E5%8A%9E%E5%85%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%5C%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A8%A1%E5%9E%8B.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/18/点击登录按钮经历了什么/" data-id="ck0v9359400072scc42rxdfvt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/18/项目一/" class="article-date">
  <time datetime="2019-09-17T17:28:59.843Z" itemprop="datePublished">2019-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/18/项目一/">做一个小项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="项目一"><a href="#项目一" class="headerlink" title="项目一"></a>项目一</h3><ol>
<li>项目结构目录</li>
</ol>
<p>​    |- admin 存储我们所有的后台程序</p>
<p>​    |- client 客户端（前端）所有的程序</p>
<ol start="2">
<li>admin</li>
</ol>
<p>&gt; 首先跑环境：$ npm i </p>
<p>&gt; 纠正一些基础的配置：config.js</p>
<p>&gt;   - PORT 后台程序运行的端口</p>
<p>&gt;   - CROS.ALLOW_ORIGIN 客户端程序运行的服务地址</p>
<p>&gt; 启动服务：$ node server.js</p>
<p>&gt; 启动后的运行窗口不能关闭，关闭则后台服务器结束</p>
<blockquote>
<p>客户端采用的技术栈：</p>
</blockquote>
<p>- HTML5/CSS3（会用到字体图标）</p>
<p>- JQUERY</p>
<p>- AXIOS</p>
<p>- 辅助插件：JQUERY.COOKIE / MD5 / 自己写的一些方法</p>
<p>- 基于IFRAME构建最初版本的SPA单页面应用开发</p>
<p>服务端采用的技术栈：</p>
<p>- NODE</p>
<p>- EXPRESS / EXPRESS-ROUTER</p>
<p>- 本应基于数据库存储，为了方便简单，当前项目临时采用JSON文件存储数据</p>
<p>- SESSION</p>
<p>-—————-</p>
<h3 id="本地存储-VS-服务器存储"><a href="#本地存储-VS-服务器存储" class="headerlink" title="本地存储 VS 服务器存储"></a>本地存储 VS 服务器存储</h3><ol start="2">
<li>本地存储：把信息存储在客户端本地</li>
</ol>
<p>&gt; 谷歌控制台Application中都可以查看到</p>
<p>- cookie</p>
<p>- H5中WebStorage：localStorage / sessionStorage</p>
<p>- 本地数据库存储：IndexDB</p>
<p>- 本地缓存存储：manifest</p>
<p>- …</p>
<ol start="2">
<li>服务器存储：把数据存储在服务器端</li>
</ol>
<p>- 数据库存储：SQLSERVER / MYSQL / ORACLE / MONGODB …</p>
<p>- REDIS</p>
<p>- SESSION</p>
<p>- …</p>
<p><img src="C:%5CUsers%5Cpc%5CDesktop%5C%E8%80%81%E5%B8%88%E7%9A%84%E7%AC%94%E8%AE%B0%5C201908%5C%E7%AC%AC%E4%B8%83%E5%91%A8%5C%E4%BC%81%E4%B8%9AOA%E5%8A%9E%E5%85%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%5C%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A8%A1%E5%9E%8B.png" alt></p>
<h2 id="什么时候会用到本地存储？本地存储的作用？"><a href="#什么时候会用到本地存储？本地存储的作用？" class="headerlink" title="什么时候会用到本地存储？本地存储的作用？"></a>什么时候会用到本地存储？本地存储的作用？</h2><ol>
<li><p>记住用户名和密码（或者自动登录）</p>
</li>
<li><p>未登录状态下，加入购物车的信息一般也先存储在本地，当登录后，把信息存储到服务器上（目的是多平台数据共享）</p>
</li>
<li><p>对于非实时刷新数据，我们可以在从服务器把数据获取到后，临时存储在本地（设置有效时间），在有效时间内页面刷新，不再重新从服务器获取数据，而是读取本地数据；超过有效时间重新从服务器拉取…  “前端性能优化的一点”</p>
</li>
<li><p>还能实现同一个网站不同页面之间的信息共享和通信</p>
</li>
</ol>
<p>​         *   ……</p>
<h2 id="本地存储到底存储在哪了？"><a href="#本地存储到底存储在哪了？" class="headerlink" title="本地存储到底存储在哪了？"></a>本地存储到底存储在哪了？</h2><ol>
<li><p>本地存储是受浏览器限制的，例如：在谷歌中存储的数据，在IE中获取不到</p>
</li>
<li><p>受源(域)的限制，例如：都是用谷歌浏览器，我在京东下存储的数据，在百度中是获取不到的</p>
</li>
</ol>
<p>​         * 本地存储的信息在控制台中可以查看到（而且是明文存储），所以敏感的数据尽可能不要存储在本地，非要存储也要做安全处理（例如：加密）</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> \* setItem([key],[value]) 存储信息</span><br><span class="line"></span><br><span class="line"> \* getItem([key]) 获取信息</span><br><span class="line"></span><br><span class="line">\* removeItem([key]) 移除某一项信息</span><br><span class="line"></span><br><span class="line">\* clear() 清除所有存储的信息</span><br><span class="line"></span><br><span class="line">\* =&gt;向本地存储的信息都是STRING字符串格式</span><br><span class="line"></span><br><span class="line">\* =&gt;localStorage是持久化存储在客户端本地的（除非手动清除或者浏览器卸载等，否则一直存储下来，没有过期时间）</span><br><span class="line"></span><br><span class="line">\* =&gt;sessionStorage会话存储（当前页面刷新，存储信息还在，但是只要页面一关闭，所有会话存储的信息都会消失）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\* 设置cookie  =&gt;jquery.cookie.js</span><br><span class="line"></span><br><span class="line">   <span class="built_in">document</span>.cookie=<span class="string">"[key]=[value];..."</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.cookie(<span class="string">'username'</span>, <span class="string">'珠峰培训'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log($.cookie(<span class="string">'username'</span>));</span><br><span class="line"></span><br><span class="line">$.removeCookie(<span class="string">'username'</span>);</span><br><span class="line"></span><br><span class="line">$.cookie(<span class="string">'username'</span>, <span class="string">'zhufeng'</span>, &#123;</span><br><span class="line">  expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)&#125;);</span><br></pre></td></tr></table></figure></code></pre><h2 id="COOKIE-VS-LOCALSTORAGE"><a href="#COOKIE-VS-LOCALSTORAGE" class="headerlink" title="COOKIE VS LOCALSTORAGE"></a>COOKIE VS LOCALSTORAGE</h2><ol>
<li><p>大小限制：一般浏览器允许一个源下COOKIE最多存储8KB，而LOCALSTORAGE被允许存储最大的长度限制是5MB</p>
</li>
<li><p>兼容性：COOKIE兼容所有浏览器，而LOCALSTORAGE是H5中新增的，不兼容IE低版本浏览器（IE6~8）</p>
</li>
<li><p>稳定性：COOKIE有过期时间，但是一般不等到时间可能就没了（例如：清除浏览器的缓存或者历史信息、安全卫士在清理电脑垃圾等操作时，都有可能会把存储的COOKIE给清除掉），但是这些操作对LOCALSTORAGE没有影响</p>
</li>
<li><p>有时候浏览器会开启无痕浏览或者隐私模式，此时无法设置COOKIE，但是可以设置LOCALSTORAGE的信息</p>
</li>
<li><p>和服务器端的猫腻：COOKIE总是会和服务器中的SESSION眉来眼去（客户端和服务器端交互的时候，COOKIE信息会传来传去），而LOCALSTORAGE不屑于和他们同流合污（LOCALSTORAGE和服务器没有必然的联系，是单纯的本地存储）</p>
</li>
<li><p>存储时间：COOKIE有过期时间，而LOCALSTORAGE是持久存储</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/18/项目一/" data-id="ck0v9359n00082scc89zzsfa0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-自己封装的Promise版(ajax)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/17/自己封装的Promise版(ajax)/" class="article-date">
  <time datetime="2019-09-17T06:24:27.383Z" itemprop="datePublished">2019-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/17/自己封装的Promise版(ajax)/">自己封装的promise版ajax</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自己封装的Promise版-ajax"><a href="#自己封装的Promise版-ajax" class="headerlink" title="自己封装的Promise版(ajax)"></a>自己封装的Promise版(ajax)</h2><h3 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h3><ul>
<li>1.支持全局默认配置项 _ajax.defaults.xxx=xxx</li>
<li>2.发送请求_ajax.get/post…</li>
<li>3.每一次请求都会返回PROMISE实例，基于PROMISE设计模式进行管理</li>
<li>4.支持_ajax.all</li>
<li>/<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;发送AJAX请求，且基于PROMISE进行管理</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyAjax</span> </span>&#123;</span><br><span class="line">		<span class="keyword">constructor</span>(url, options) &#123;</span><br><span class="line">			<span class="keyword">this</span>.url = url;</span><br><span class="line">			<span class="keyword">this</span>.options = options;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.init();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//=&gt;发送AJAX请求（基于PROMISE来管理）</span></span><br><span class="line">		init() &#123;</span><br><span class="line">			<span class="keyword">let</span> &#123;</span><br><span class="line">				url,</span><br><span class="line">				options: &#123;</span><br><span class="line">					baseURL,</span><br><span class="line">					withCredentials,</span><br><span class="line">					headers,</span><br><span class="line">					transformRequest,</span><br><span class="line">					transformResponse,</span><br><span class="line">					validateStatus,</span><br><span class="line">					params,</span><br><span class="line">					data,</span><br><span class="line">					cache,</span><br><span class="line">					method</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; = <span class="keyword">this</span>;</span><br><span class="line">			<span class="comment">//=&gt;保证响应拦截器中信息的合法性</span></span><br><span class="line">			!<span class="built_in">Array</span>.isArray(transformResponse) ? transformResponse = [] : <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="literal">null</span>).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">typeof</span> transformResponse[index] !== <span class="string">'function'</span> ? transformResponse[index] = <span class="literal">null</span> : <span class="literal">null</span>;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//=&gt;URL的处理</span></span><br><span class="line">				url = baseURL + url;</span><br><span class="line">				<span class="keyword">if</span> (<span class="regexp">/^(GET|DELETE|HEAD|OPTIONS)$/i</span>.test(method)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (params) &#123;</span><br><span class="line">						<span class="keyword">let</span> result = <span class="string">``</span>;</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> params) &#123;</span><br><span class="line">							<span class="keyword">if</span> (!params.hasOwnProperty(attr)) <span class="keyword">break</span>;</span><br><span class="line">							result += <span class="string">`&amp;<span class="subst">$&#123;attr&#125;</span>=<span class="subst">$&#123;params[attr]&#125;</span>`</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						result = result.substring(<span class="number">1</span>);</span><br><span class="line">						url += <span class="string">`<span class="subst">$&#123;url.indexOf(<span class="string">'?'</span>)===<span class="number">-1</span>?<span class="string">'?'</span>:<span class="string">'&amp;'</span>&#125;</span><span class="subst">$&#123;result&#125;</span>`</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (cache === <span class="literal">false</span>) &#123;</span><br><span class="line">						url += <span class="string">`<span class="subst">$&#123;url.indexOf(<span class="string">'?'</span>)===<span class="number">-1</span>?<span class="string">'?'</span>:<span class="string">'&amp;'</span>&#125;</span>_=<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>`</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				xhr.open(method, url);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//=&gt;结果处理</span></span><br><span class="line">				xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> resultFlag = validateStatus(xhr.status);</span><br><span class="line">					<span class="keyword">if</span> (!resultFlag) &#123;</span><br><span class="line">						reject(&#123;</span><br><span class="line">							status: xhr.status,</span><br><span class="line">							statusText: xhr.statusText,</span><br><span class="line">							request: xhr</span><br><span class="line">						&#125;);</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">						<span class="keyword">let</span> res_headers = &#123;&#125;;</span><br><span class="line">						xhr.getAllResponseHeaders().split(<span class="regexp">/\n/</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">							<span class="keyword">let</span> [key = <span class="string">''</span>, value = <span class="string">''</span>] = item.split(<span class="string">':'</span>);</span><br><span class="line">							<span class="keyword">if</span> (key.trim() === <span class="string">''</span>) <span class="keyword">return</span>;</span><br><span class="line">							res_headers[key.trim()] = value.trim();</span><br><span class="line">						&#125;);</span><br><span class="line">						resolve(&#123;</span><br><span class="line">							status: xhr.status,</span><br><span class="line">							statusText: xhr.statusText,</span><br><span class="line">							request: xhr,</span><br><span class="line">							data: <span class="built_in">JSON</span>.parse(xhr.responseText),</span><br><span class="line">							headers: res_headers</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//=&gt;跨域处理</span></span><br><span class="line">				xhr.withCredentials = withCredentials;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//=&gt;设置请求头</span></span><br><span class="line">				<span class="keyword">if</span> (headers) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> headers) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!headers.hasOwnProperty(attr)) <span class="keyword">break</span>;</span><br><span class="line">						xhr.setRequestHeader(attr, <span class="built_in">encodeURI</span>(headers[attr]));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//=&gt;请求拦截器：请求主体传递信息的拦截</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="regexp">/^(POST|PUT)$/i</span>.test(method)) &#123;</span><br><span class="line">					<span class="keyword">typeof</span> transformRequest === <span class="string">'function'</span> ? data = transformRequest(data) : <span class="literal">null</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					data = <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				xhr.send(data);</span><br><span class="line">			&#125;).then(...transformResponse);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//=&gt;创建_ajax管理调用</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">_init</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//=&gt;参数初始化：HEADERS需要特殊处理（把用户OPTIONS中传递的HEADERS，和DEFAULTS中的HEADERS进行合并，而不是整体替换），其余的配置项直接用OPTIONS中的替换DEFAULTS中的即可；</span></span><br><span class="line">		<span class="keyword">let</span> optionsHeaders = options.headers;</span><br><span class="line">		_ajax.defaults.headers = <span class="built_in">Object</span>.assign(_ajax.defaults.headers, optionsHeaders);</span><br><span class="line">		<span class="keyword">delete</span> options.headers;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.assign(_ajax.defaults, options);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">_ajax</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	_ajax.defaults = &#123;</span><br><span class="line">		<span class="comment">//=&gt;全局配置项</span></span><br><span class="line">		baseURL: <span class="string">''</span>,</span><br><span class="line">		withCredentials: <span class="literal">true</span>,</span><br><span class="line">		headers: &#123;</span><br><span class="line">			<span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">		&#125;,</span><br><span class="line">		transformRequest: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!data) <span class="keyword">return</span> data;</span><br><span class="line">			<span class="keyword">let</span> result = <span class="string">``</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> data) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!data.hasOwnProperty(attr)) <span class="keyword">break</span>;</span><br><span class="line">				result += <span class="string">`&amp;<span class="subst">$&#123;attr&#125;</span>=<span class="subst">$&#123;data[attr]&#125;</span>`</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result.substring(<span class="number">1</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		transformResponse: [<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> response.data;</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">		&#125;],</span><br><span class="line">		validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="regexp">/^(2|3)\d&#123;2&#125;$/</span>.test(status);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//=&gt;请求配置项</span></span><br><span class="line">		params: &#123;&#125;,</span><br><span class="line">		data: &#123;&#125;,</span><br><span class="line">		cache: <span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_ajax.all = <span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">promiseArr = []</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Promise</span>.all(promiseArr);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	[<span class="string">"get"</span>, <span class="string">"delete"</span>, <span class="string">"head"</span>, <span class="string">"options"</span>].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">		_ajax[item] = <span class="function"><span class="keyword">function</span> (<span class="params">url, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">			options.method = item;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyAjax(url, _init(options));</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	[<span class="string">"post"</span>, <span class="string">"put"</span>].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">		_ajax[item] = <span class="function"><span class="keyword">function</span> (<span class="params">url, data = &#123;&#125;, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">			<span class="comment">//=&gt;把DATA也放到配置项目</span></span><br><span class="line">			options.data = data;</span><br><span class="line">			options.method = item;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyAjax(url, _init(options));</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">window</span>._ajax = _ajax;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>axios：一款基于PROMISE设计模式封装的AJAX库（JQ中的AJAX就是最普通的AJAX库，没有基于PROMISE管理） </p>
<ol>
<li>axios.get([URL],[OPTIONS]);<ol start="2">
<li>axios.get();</li>
<li>axios.delete();</li>
<li>axios.head();</li>
<li>axios.post([URL],[DATA],[OPTIONS])：DATA通过请求主传递给服务器的内容</li>
<li>axios.post();</li>
<li>axios.put();</li>
</ol>
</li>
</ol>
</blockquote>
<pre><code>* OPTIONS
*   baseURL：基础的URL路径 
*   transformRequest：处理请求参数（对POST系列有作用）
*   transformResponse：把返回的结果进行处理
*   headers：设置请求头
*   params：GET系列请求传递给服务器的内容（会把PARAMS中的内容拼接为X-WWW-FORM-URLENCODED这种格式，基于URL问号传参传递给服务器）
*   paramsSerializer：传递参数的序列化
*   timeout：超时时间
*   withCredentials：跨域请求中是否允许携带凭证
*   responseType：预设服务器返回结果的格式，默认是JSON，支持BUFFER/TEXT/STREAM/DOCUMENT...
*   validateStatus：AXIOS本身只有在HTTP状态码以2开头的时候才认为是成功，其余都认为是失败状态，当然我们可以自己来设置，基于validateStatus这个来修改
*   ......</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//=&gt;执行axios.xxx()都会返回一个PROMISE实例，AJAX请求成功会把实例的状态改为FULFILLED，请求失败状态改为REJECTED；并且获取的结果或者错误原因作为PROMISE的VALUE</span></span><br><span class="line">	<span class="comment">/* axios.get('http://127.0.0.1:5500/json/data2.json', &#123;</span></span><br><span class="line"><span class="comment">		headers: &#123;</span></span><br><span class="line"><span class="comment">			AAA: encodeURIComponent('珠峰哈哈哈')</span></span><br><span class="line"><span class="comment">		&#125;,</span></span><br><span class="line"><span class="comment">		params: &#123;</span></span><br><span class="line"><span class="comment">			lx: 1,</span></span><br><span class="line"><span class="comment">			from: 'WX'</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;).then(result =&gt; &#123;</span></span><br><span class="line"><span class="comment">		//=&gt;result：从服务器获取的结果</span></span><br><span class="line"><span class="comment">		/!*</span></span><br><span class="line"><span class="comment">		 * CONFIG：我们自己配置的选项信息</span></span><br><span class="line"><span class="comment">		 * DATA：存储的是响应主体内容 </span></span><br><span class="line"><span class="comment">		 * HEADERS：存储响应头的信息</span></span><br><span class="line"><span class="comment">		 * REQUEST：AJAX实例</span></span><br><span class="line"><span class="comment">		 * STATUS：响应状态码</span></span><br><span class="line"><span class="comment">		 * STATUS-TEXT：状态码的描述</span></span><br><span class="line"><span class="comment">		 *!/</span></span><br><span class="line"><span class="comment">		return result.data;</span></span><br><span class="line"><span class="comment">	&#125;).catch(reason =&gt; &#123;</span></span><br><span class="line"><span class="comment">		console.log(reason);</span></span><br><span class="line"><span class="comment">		throw new Error(reason);</span></span><br><span class="line"><span class="comment">	&#125;).then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">		//=&gt;data：从服务器获取的响应主体内容</span></span><br><span class="line"><span class="comment">		console.log(data);</span></span><br><span class="line"><span class="comment">	&#125;); */</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	/</span>* axios.post(<span class="string">'http://127.0.0.1:5500/json/data2.json'</span>, &#123;</span><br><span class="line">		lx: <span class="number">1</span>,</span><br><span class="line">		<span class="keyword">from</span>: <span class="string">'WX'</span></span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		headers: &#123;</span><br><span class="line">			AAA: <span class="built_in">encodeURIComponent</span>(<span class="string">'珠峰哈哈哈'</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		transformRequest: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!data) <span class="keyword">return</span> data;</span><br><span class="line">			<span class="keyword">let</span> str = <span class="string">``</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!data.hasOwnProperty(key)) <span class="keyword">break</span>;</span><br><span class="line">				str += <span class="string">`&amp;<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>`</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> str.substring(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result.data;</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason);</span><br><span class="line">	&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125;); *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="comment">/* 在使用AXIOS之前，我们一般都需要配置默认的配置项 */</span></span><br><span class="line">	<span class="comment">// 1.基础URL，后期再发送请求的时候，URL请求地址最前面的公共部分就不需要再写了</span></span><br><span class="line">	axios.defaults.baseURL = <span class="string">"http://127.0.0.1:5500"</span>;</span><br><span class="line">	<span class="comment">// 2.跨域请求中允许携带资源凭证（例如COOKIE信息）</span></span><br><span class="line">	axios.defaults.withCredentials = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 3.设置请求头:POST系列中，我们传递给服务器数据的格式一般以x-www-form-urlencoded格式为主</span></span><br><span class="line">	axios.defaults.headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line">	<span class="comment">// 4.设置请求拦截器（只对POST系列有用）：把基于请求主体传递给服务器的内容进行拦截，把内容格式变为x-www-form-urlencoded这种格式，再传递给服务器</span></span><br><span class="line">	axios.defaults.transformRequest = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data) <span class="keyword">return</span> data;</span><br><span class="line">		<span class="keyword">let</span> str = <span class="string">``</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!data.hasOwnProperty(key)) <span class="keyword">break</span>;</span><br><span class="line">			str += <span class="string">`&amp;<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>`</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 5.设置响应拦截器：[成功状态]把从服务器获取的结果中的响应主体信息获取到即可，[失败状态]手动把错误信息抛出异常</span></span><br><span class="line">	axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> response.data;</span><br><span class="line">	&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 6.配置什么才算成功（把PROMISE状态改为FULFILLED）</span></span><br><span class="line">	axios.defaults.validateStatus = <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="regexp">/^(2|3)\d&#123;2&#125;$/</span>.test(status);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// axios.get('/json/data2.json').then(data =&gt; &#123;</span></span><br><span class="line">	<span class="comment">// 	console.log(data);</span></span><br><span class="line">	<span class="comment">// &#125;).catch(reason =&gt; &#123;</span></span><br><span class="line">	<span class="comment">// 	console.log(reason);</span></span><br><span class="line">	<span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//=&gt;Promise.all</span></span><br><span class="line">	<span class="keyword">let</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">200</span>);</span><br><span class="line">	axios.all([promise1, promise2]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> [val1, val2] = results;</span><br><span class="line">		<span class="built_in">console</span>.log(val1, val2);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">/* axios.all([promise1, promise2]).then(axios.spread(function (val1, val2) &#123;</span></span><br><span class="line"><span class="comment">		//=&gt;axios.spread：把基于axios.all获取的结果一项项的单独获取到</span></span><br><span class="line"><span class="comment">		console.log(val1, val2);</span></span><br><span class="line"><span class="comment">	&#125;)) */</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/17/自己封装的Promise版(ajax)/" data-id="ck0v9359u000a2scci9z03om8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/21/NODE的学习笔记/">NODE的学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/09/19/存储的作用/">存储的作用</a>
          </li>
        
          <li>
            <a href="/2019/09/19/一个倒计时案例/">一个倒计时案例</a>
          </li>
        
          <li>
            <a href="/2019/09/19/权限校验从用户成功登陆开始/">权限校验</a>
          </li>
        
          <li>
            <a href="/2019/09/19/AJAX核心处理/">AJAX的学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Faker<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>